#!/bin/bash

bad_munge() {
    echo "[ERROR] $(basename -- $0) MUNGE_PATTERN must a single non-empty word; percent (%) is reserved; it must not be affected by shell expansion."
    exit 2
}

MUNGE='^==^'

# Check everything you can about the munge chars...abort on any issue...
if [[ "$1" == --munge ]]; then
    MUNGE=$2

    # Check for white space...
    read -ra MUNGE_PARTS <<< "$MUNGE"
    if [[ ${#MUNGE_PARTS[*]} -ne 1 ]]; then
        bad_munge
    fi

    # Check for shell-expansion changes...
    eval MUNGE_CHECK=${MUNGE}
    echo ===$MUNGE===  ===$MUNGE_CHECK===
    if [[ "$MUNGE" =~ % || -z "$MUNGE" || "$MUNGE" != "$MUNGE_CHECK" ]]; then
        bad_munge
    fi
    shift; shift
fi

# Run
export MUNGE
git filter-branch -f --tree-filter '
    # get file list separated by the MUNGE PATTERN", something not expected to be seen in any file names with RSA keys in them...
    file_list=$(grep -l --null -R "BEGIN RSA PRIVATE KEY" * 2>/dev/null | xargs -0 -R 1 -I % echo '$MUNGE'% | tr " '$MUNGE'" "'$MUNGE'" | tr -d "\\n" || true)
    echo
    echo ${file_list} #debugging
    if [[ -n "$file_list" ]]; then echo; fi 
    IFS="'$MUNGE'"
    echo '$MUNGE' is MUNGE
    for f in $file_list; do
        [[ -z "$f" ]] && continue
        echo File: $f
        # grab all the lines of the key itself, substituting sed-special characters / and +
        sed -e "/-----BEGIN RSA PRIVATE KEY-----/,/-----END RSA PRIVATE KEY-----/p" -e "1,\$d" "$f" |
            sed -e "/RSA PRIVATE KEY/d" -e "s:[/+]:.:g" -e "s:^:/:" -e "s:$:/d:" >/tmp/key_delete$$.txt

        if [[ -s /tmp/key_delete$$.txt ]]; then
            echo; echo File: $f
            echo
            cat /tmp/key_delete$$.txt

            # this sed command works on MAC. For other (LINUX) change to sed -i"" -f ...
            sed -i "" -f /tmp/key_delete$$.txt "$f"
        fi
        #rm -f /tmp/key_delete$$.txt
    done
    unset IFS' $@
